// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BalanceDripActivated extends ethereum.Event {
  get params(): BalanceDripActivated__Params {
    return new BalanceDripActivated__Params(this);
  }
}

export class BalanceDripActivated__Params {
  _event: BalanceDripActivated;

  constructor(event: BalanceDripActivated) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get dripRatePerSecond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class BalanceDripDeactivated extends ethereum.Event {
  get params(): BalanceDripDeactivated__Params {
    return new BalanceDripDeactivated__Params(this);
  }
}

export class BalanceDripDeactivated__Params {
  _event: BalanceDripDeactivated;

  constructor(event: BalanceDripDeactivated) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class BalanceDripDripped extends ethereum.Event {
  get params(): BalanceDripDripped__Params {
    return new BalanceDripDripped__Params(this);
  }
}

export class BalanceDripDripped__Params {
  _event: BalanceDripDripped;

  constructor(event: BalanceDripDripped) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get user(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class BalanceDripRateSet extends ethereum.Event {
  get params(): BalanceDripRateSet__Params {
    return new BalanceDripRateSet__Params(this);
  }
}

export class BalanceDripRateSet__Params {
  _event: BalanceDripRateSet;

  constructor(event: BalanceDripRateSet) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get dripRatePerSecond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class DripTokenClaimed extends ethereum.Event {
  get params(): DripTokenClaimed__Params {
    return new DripTokenClaimed__Params(this);
  }
}

export class DripTokenClaimed__Params {
  _event: DripTokenClaimed;

  constructor(event: DripTokenClaimed) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get user(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class DripTokenDripped extends ethereum.Event {
  get params(): DripTokenDripped__Params {
    return new DripTokenDripped__Params(this);
  }
}

export class DripTokenDripped__Params {
  _event: DripTokenDripped;

  constructor(event: DripTokenDripped) {
    this._event = event;
  }

  get dripToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get user(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class TransferredOut extends ethereum.Event {
  get params(): TransferredOut__Params {
    return new TransferredOut__Params(this);
  }
}

export class TransferredOut__Params {
  _event: TransferredOut;

  constructor(event: TransferredOut) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class VolumeDripActivated extends ethereum.Event {
  get params(): VolumeDripActivated__Params {
    return new VolumeDripActivated__Params(this);
  }
}

export class VolumeDripActivated__Params {
  _event: VolumeDripActivated;

  constructor(event: VolumeDripActivated) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get periodSeconds(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get dripAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class VolumeDripDeactivated extends ethereum.Event {
  get params(): VolumeDripDeactivated__Params {
    return new VolumeDripDeactivated__Params(this);
  }
}

export class VolumeDripDeactivated__Params {
  _event: VolumeDripDeactivated;

  constructor(event: VolumeDripDeactivated) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }
}

export class VolumeDripDripped extends ethereum.Event {
  get params(): VolumeDripDripped__Params {
    return new VolumeDripDripped__Params(this);
  }
}

export class VolumeDripDripped__Params {
  _event: VolumeDripDripped;

  constructor(event: VolumeDripDripped) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get user(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class VolumeDripPeriodEnded extends ethereum.Event {
  get params(): VolumeDripPeriodEnded__Params {
    return new VolumeDripPeriodEnded__Params(this);
  }
}

export class VolumeDripPeriodEnded__Params {
  _event: VolumeDripPeriodEnded;

  constructor(event: VolumeDripPeriodEnded) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get period(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get totalSupply(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get drippedTokens(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class VolumeDripPeriodStarted extends ethereum.Event {
  get params(): VolumeDripPeriodStarted__Params {
    return new VolumeDripPeriodStarted__Params(this);
  }
}

export class VolumeDripPeriodStarted__Params {
  _event: VolumeDripPeriodStarted;

  constructor(event: VolumeDripPeriodStarted) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get period(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get dripAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get endTime(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class VolumeDripSet extends ethereum.Event {
  get params(): VolumeDripSet__Params {
    return new VolumeDripSet__Params(this);
  }
}

export class VolumeDripSet__Params {
  _event: VolumeDripSet;

  constructor(event: VolumeDripSet) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get measure(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get periodSeconds(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get dripAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class Comptroller__balanceOfClaimsResultValue0Struct extends ethereum.Tuple {
  get dripToken(): Address {
    return this[0].toAddress();
  }

  get balance(): BigInt {
    return this[1].toBigInt();
  }
}

export class Comptroller__getBalanceDripResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class Comptroller__getVolumeDripResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class Comptroller__getVolumeDripPeriodResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class Comptroller__updateAndClaimDripsResultValue0Struct extends ethereum.Tuple {
  get dripToken(): Address {
    return this[0].toAddress();
  }

  get balance(): BigInt {
    return this[1].toBigInt();
  }
}

export class Comptroller__updateAndClaimDripsInputPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class Comptroller__updateDripsResultValue0Struct extends ethereum.Tuple {
  get dripToken(): Address {
    return this[0].toAddress();
  }

  get balance(): BigInt {
    return this[1].toBigInt();
  }
}

export class Comptroller__updateDripsInputPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class Comptroller extends ethereum.SmartContract {
  static bind(address: Address): Comptroller {
    return new Comptroller("Comptroller", address);
  }

  balanceOfClaims(
    user: Address,
    dripTokens: Array<Address>
  ): Array<Comptroller__balanceOfClaimsResultValue0Struct> {
    let result = super.call(
      "balanceOfClaims",
      "balanceOfClaims(address,address[]):(tuple[])",
      [
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddressArray(dripTokens)
      ]
    );

    return result[0].toTupleArray<
      Comptroller__balanceOfClaimsResultValue0Struct
    >();
  }

  try_balanceOfClaims(
    user: Address,
    dripTokens: Array<Address>
  ): ethereum.CallResult<
    Array<Comptroller__balanceOfClaimsResultValue0Struct>
  > {
    let result = super.tryCall(
      "balanceOfClaims",
      "balanceOfClaims(address,address[]):(tuple[])",
      [
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddressArray(dripTokens)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Comptroller__balanceOfClaimsResultValue0Struct>()
    );
  }

  balanceOfDrip(user: Address, dripToken: Address): BigInt {
    let result = super.call(
      "balanceOfDrip",
      "balanceOfDrip(address,address):(uint256)",
      [ethereum.Value.fromAddress(user), ethereum.Value.fromAddress(dripToken)]
    );

    return result[0].toBigInt();
  }

  try_balanceOfDrip(
    user: Address,
    dripToken: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceOfDrip",
      "balanceOfDrip(address,address):(uint256)",
      [ethereum.Value.fromAddress(user), ethereum.Value.fromAddress(dripToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getActiveBalanceDripTokens(
    source: Address,
    measure: Address
  ): Array<Address> {
    let result = super.call(
      "getActiveBalanceDripTokens",
      "getActiveBalanceDripTokens(address,address):(address[])",
      [ethereum.Value.fromAddress(source), ethereum.Value.fromAddress(measure)]
    );

    return result[0].toAddressArray();
  }

  try_getActiveBalanceDripTokens(
    source: Address,
    measure: Address
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getActiveBalanceDripTokens",
      "getActiveBalanceDripTokens(address,address):(address[])",
      [ethereum.Value.fromAddress(source), ethereum.Value.fromAddress(measure)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getActiveVolumeDripTokens(
    source: Address,
    measure: Address,
    isReferral: boolean
  ): Array<Address> {
    let result = super.call(
      "getActiveVolumeDripTokens",
      "getActiveVolumeDripTokens(address,address,bool):(address[])",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromBoolean(isReferral)
      ]
    );

    return result[0].toAddressArray();
  }

  try_getActiveVolumeDripTokens(
    source: Address,
    measure: Address,
    isReferral: boolean
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getActiveVolumeDripTokens",
      "getActiveVolumeDripTokens(address,address,bool):(address[])",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromBoolean(isReferral)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getBalanceDrip(
    source: Address,
    measure: Address,
    dripToken: Address
  ): Comptroller__getBalanceDripResult {
    let result = super.call(
      "getBalanceDrip",
      "getBalanceDrip(address,address,address):(uint256,uint128,uint32)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken)
      ]
    );

    return new Comptroller__getBalanceDripResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getBalanceDrip(
    source: Address,
    measure: Address,
    dripToken: Address
  ): ethereum.CallResult<Comptroller__getBalanceDripResult> {
    let result = super.tryCall(
      "getBalanceDrip",
      "getBalanceDrip(address,address,address):(uint256,uint128,uint32)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Comptroller__getBalanceDripResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  getVolumeDrip(
    source: Address,
    measure: Address,
    dripToken: Address,
    isReferral: boolean
  ): Comptroller__getVolumeDripResult {
    let result = super.call(
      "getVolumeDrip",
      "getVolumeDrip(address,address,address,bool):(uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken),
        ethereum.Value.fromBoolean(isReferral)
      ]
    );

    return new Comptroller__getVolumeDripResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getVolumeDrip(
    source: Address,
    measure: Address,
    dripToken: Address,
    isReferral: boolean
  ): ethereum.CallResult<Comptroller__getVolumeDripResult> {
    let result = super.tryCall(
      "getVolumeDrip",
      "getVolumeDrip(address,address,address,bool):(uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken),
        ethereum.Value.fromBoolean(isReferral)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Comptroller__getVolumeDripResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  getVolumeDripPeriod(
    source: Address,
    measure: Address,
    dripToken: Address,
    isReferral: boolean,
    period: i32
  ): Comptroller__getVolumeDripPeriodResult {
    let result = super.call(
      "getVolumeDripPeriod",
      "getVolumeDripPeriod(address,address,address,bool,uint16):(uint112,uint112,uint32)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken),
        ethereum.Value.fromBoolean(isReferral),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(period))
      ]
    );

    return new Comptroller__getVolumeDripPeriodResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getVolumeDripPeriod(
    source: Address,
    measure: Address,
    dripToken: Address,
    isReferral: boolean,
    period: i32
  ): ethereum.CallResult<Comptroller__getVolumeDripPeriodResult> {
    let result = super.tryCall(
      "getVolumeDripPeriod",
      "getVolumeDripPeriod(address,address,address,bool,uint16):(uint112,uint112,uint32)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken),
        ethereum.Value.fromBoolean(isReferral),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(period))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Comptroller__getVolumeDripPeriodResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  isVolumeDripActive(
    source: Address,
    measure: Address,
    dripToken: Address,
    isReferral: boolean
  ): boolean {
    let result = super.call(
      "isVolumeDripActive",
      "isVolumeDripActive(address,address,address,bool):(bool)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken),
        ethereum.Value.fromBoolean(isReferral)
      ]
    );

    return result[0].toBoolean();
  }

  try_isVolumeDripActive(
    source: Address,
    measure: Address,
    dripToken: Address,
    isReferral: boolean
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isVolumeDripActive",
      "isVolumeDripActive(address,address,address,bool):(bool)",
      [
        ethereum.Value.fromAddress(source),
        ethereum.Value.fromAddress(measure),
        ethereum.Value.fromAddress(dripToken),
        ethereum.Value.fromBoolean(isReferral)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  updateAndClaimDrips(
    pairs: Array<Comptroller__updateAndClaimDripsInputPairsStruct>,
    user: Address,
    dripTokens: Array<Address>
  ): Array<Comptroller__updateAndClaimDripsResultValue0Struct> {
    let result = super.call(
      "updateAndClaimDrips",
      "updateAndClaimDrips(tuple[],address,address[]):(tuple[])",
      [
        ethereum.Value.fromTupleArray(pairs),
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddressArray(dripTokens)
      ]
    );

    return result[0].toTupleArray<
      Comptroller__updateAndClaimDripsResultValue0Struct
    >();
  }

  try_updateAndClaimDrips(
    pairs: Array<Comptroller__updateAndClaimDripsInputPairsStruct>,
    user: Address,
    dripTokens: Array<Address>
  ): ethereum.CallResult<
    Array<Comptroller__updateAndClaimDripsResultValue0Struct>
  > {
    let result = super.tryCall(
      "updateAndClaimDrips",
      "updateAndClaimDrips(tuple[],address,address[]):(tuple[])",
      [
        ethereum.Value.fromTupleArray(pairs),
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddressArray(dripTokens)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        Comptroller__updateAndClaimDripsResultValue0Struct
      >()
    );
  }

  updateDrips(
    pairs: Array<Comptroller__updateDripsInputPairsStruct>,
    user: Address,
    dripTokens: Array<Address>
  ): Array<Comptroller__updateDripsResultValue0Struct> {
    let result = super.call(
      "updateDrips",
      "updateDrips(tuple[],address,address[]):(tuple[])",
      [
        ethereum.Value.fromTupleArray(pairs),
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddressArray(dripTokens)
      ]
    );

    return result[0].toTupleArray<Comptroller__updateDripsResultValue0Struct>();
  }

  try_updateDrips(
    pairs: Array<Comptroller__updateDripsInputPairsStruct>,
    user: Address,
    dripTokens: Array<Address>
  ): ethereum.CallResult<Array<Comptroller__updateDripsResultValue0Struct>> {
    let result = super.tryCall(
      "updateDrips",
      "updateDrips(tuple[],address,address[]):(tuple[])",
      [
        ethereum.Value.fromTupleArray(pairs),
        ethereum.Value.fromAddress(user),
        ethereum.Value.fromAddressArray(dripTokens)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Comptroller__updateDripsResultValue0Struct>()
    );
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ActivateBalanceDripCall extends ethereum.Call {
  get inputs(): ActivateBalanceDripCall__Inputs {
    return new ActivateBalanceDripCall__Inputs(this);
  }

  get outputs(): ActivateBalanceDripCall__Outputs {
    return new ActivateBalanceDripCall__Outputs(this);
  }
}

export class ActivateBalanceDripCall__Inputs {
  _call: ActivateBalanceDripCall;

  constructor(call: ActivateBalanceDripCall) {
    this._call = call;
  }

  get source(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get measure(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get dripRatePerSecond(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ActivateBalanceDripCall__Outputs {
  _call: ActivateBalanceDripCall;

  constructor(call: ActivateBalanceDripCall) {
    this._call = call;
  }
}

export class ActivateVolumeDripCall extends ethereum.Call {
  get inputs(): ActivateVolumeDripCall__Inputs {
    return new ActivateVolumeDripCall__Inputs(this);
  }

  get outputs(): ActivateVolumeDripCall__Outputs {
    return new ActivateVolumeDripCall__Outputs(this);
  }
}

export class ActivateVolumeDripCall__Inputs {
  _call: ActivateVolumeDripCall;

  constructor(call: ActivateVolumeDripCall) {
    this._call = call;
  }

  get source(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get measure(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get periodSeconds(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get dripAmount(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get endTime(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }
}

export class ActivateVolumeDripCall__Outputs {
  _call: ActivateVolumeDripCall;

  constructor(call: ActivateVolumeDripCall) {
    this._call = call;
  }
}

export class BeforeTokenMintCall extends ethereum.Call {
  get inputs(): BeforeTokenMintCall__Inputs {
    return new BeforeTokenMintCall__Inputs(this);
  }

  get outputs(): BeforeTokenMintCall__Outputs {
    return new BeforeTokenMintCall__Outputs(this);
  }
}

export class BeforeTokenMintCall__Inputs {
  _call: BeforeTokenMintCall;

  constructor(call: BeforeTokenMintCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get measure(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get referrer(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class BeforeTokenMintCall__Outputs {
  _call: BeforeTokenMintCall;

  constructor(call: BeforeTokenMintCall) {
    this._call = call;
  }
}

export class BeforeTokenTransferCall extends ethereum.Call {
  get inputs(): BeforeTokenTransferCall__Inputs {
    return new BeforeTokenTransferCall__Inputs(this);
  }

  get outputs(): BeforeTokenTransferCall__Outputs {
    return new BeforeTokenTransferCall__Outputs(this);
  }
}

export class BeforeTokenTransferCall__Inputs {
  _call: BeforeTokenTransferCall;

  constructor(call: BeforeTokenTransferCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get measure(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class BeforeTokenTransferCall__Outputs {
  _call: BeforeTokenTransferCall;

  constructor(call: BeforeTokenTransferCall) {
    this._call = call;
  }
}

export class CaptureClaimsForBalanceDripsForPairsCall extends ethereum.Call {
  get inputs(): CaptureClaimsForBalanceDripsForPairsCall__Inputs {
    return new CaptureClaimsForBalanceDripsForPairsCall__Inputs(this);
  }

  get outputs(): CaptureClaimsForBalanceDripsForPairsCall__Outputs {
    return new CaptureClaimsForBalanceDripsForPairsCall__Outputs(this);
  }
}

export class CaptureClaimsForBalanceDripsForPairsCall__Inputs {
  _call: CaptureClaimsForBalanceDripsForPairsCall;

  constructor(call: CaptureClaimsForBalanceDripsForPairsCall) {
    this._call = call;
  }

  get pairs(): Array<CaptureClaimsForBalanceDripsForPairsCallPairsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      CaptureClaimsForBalanceDripsForPairsCallPairsStruct
    >();
  }

  get user(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripTokens(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }
}

export class CaptureClaimsForBalanceDripsForPairsCall__Outputs {
  _call: CaptureClaimsForBalanceDripsForPairsCall;

  constructor(call: CaptureClaimsForBalanceDripsForPairsCall) {
    this._call = call;
  }
}

export class CaptureClaimsForBalanceDripsForPairsCallPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class ClaimDripCall extends ethereum.Call {
  get inputs(): ClaimDripCall__Inputs {
    return new ClaimDripCall__Inputs(this);
  }

  get outputs(): ClaimDripCall__Outputs {
    return new ClaimDripCall__Outputs(this);
  }
}

export class ClaimDripCall__Inputs {
  _call: ClaimDripCall;

  constructor(call: ClaimDripCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ClaimDripCall__Outputs {
  _call: ClaimDripCall;

  constructor(call: ClaimDripCall) {
    this._call = call;
  }
}

export class ClaimDripsCall extends ethereum.Call {
  get inputs(): ClaimDripsCall__Inputs {
    return new ClaimDripsCall__Inputs(this);
  }

  get outputs(): ClaimDripsCall__Outputs {
    return new ClaimDripsCall__Outputs(this);
  }
}

export class ClaimDripsCall__Inputs {
  _call: ClaimDripsCall;

  constructor(call: ClaimDripsCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get dripTokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }
}

export class ClaimDripsCall__Outputs {
  _call: ClaimDripsCall;

  constructor(call: ClaimDripsCall) {
    this._call = call;
  }
}

export class DeactivateBalanceDripCall extends ethereum.Call {
  get inputs(): DeactivateBalanceDripCall__Inputs {
    return new DeactivateBalanceDripCall__Inputs(this);
  }

  get outputs(): DeactivateBalanceDripCall__Outputs {
    return new DeactivateBalanceDripCall__Outputs(this);
  }
}

export class DeactivateBalanceDripCall__Inputs {
  _call: DeactivateBalanceDripCall;

  constructor(call: DeactivateBalanceDripCall) {
    this._call = call;
  }

  get source(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get measure(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get prevDripToken(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class DeactivateBalanceDripCall__Outputs {
  _call: DeactivateBalanceDripCall;

  constructor(call: DeactivateBalanceDripCall) {
    this._call = call;
  }
}

export class DeactivateVolumeDripCall extends ethereum.Call {
  get inputs(): DeactivateVolumeDripCall__Inputs {
    return new DeactivateVolumeDripCall__Inputs(this);
  }

  get outputs(): DeactivateVolumeDripCall__Outputs {
    return new DeactivateVolumeDripCall__Outputs(this);
  }
}

export class DeactivateVolumeDripCall__Inputs {
  _call: DeactivateVolumeDripCall;

  constructor(call: DeactivateVolumeDripCall) {
    this._call = call;
  }

  get source(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get measure(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get prevDripToken(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class DeactivateVolumeDripCall__Outputs {
  _call: DeactivateVolumeDripCall;

  constructor(call: DeactivateVolumeDripCall) {
    this._call = call;
  }
}

export class MintAndCaptureVolumeDripsForPairsCall extends ethereum.Call {
  get inputs(): MintAndCaptureVolumeDripsForPairsCall__Inputs {
    return new MintAndCaptureVolumeDripsForPairsCall__Inputs(this);
  }

  get outputs(): MintAndCaptureVolumeDripsForPairsCall__Outputs {
    return new MintAndCaptureVolumeDripsForPairsCall__Outputs(this);
  }
}

export class MintAndCaptureVolumeDripsForPairsCall__Inputs {
  _call: MintAndCaptureVolumeDripsForPairsCall;

  constructor(call: MintAndCaptureVolumeDripsForPairsCall) {
    this._call = call;
  }

  get pairs(): Array<MintAndCaptureVolumeDripsForPairsCallPairsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      MintAndCaptureVolumeDripsForPairsCallPairsStruct
    >();
  }

  get user(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get dripTokens(): Array<Address> {
    return this._call.inputValues[3].value.toAddressArray();
  }
}

export class MintAndCaptureVolumeDripsForPairsCall__Outputs {
  _call: MintAndCaptureVolumeDripsForPairsCall;

  constructor(call: MintAndCaptureVolumeDripsForPairsCall) {
    this._call = call;
  }
}

export class MintAndCaptureVolumeDripsForPairsCallPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SetBalanceDripRateCall extends ethereum.Call {
  get inputs(): SetBalanceDripRateCall__Inputs {
    return new SetBalanceDripRateCall__Inputs(this);
  }

  get outputs(): SetBalanceDripRateCall__Outputs {
    return new SetBalanceDripRateCall__Outputs(this);
  }
}

export class SetBalanceDripRateCall__Inputs {
  _call: SetBalanceDripRateCall;

  constructor(call: SetBalanceDripRateCall) {
    this._call = call;
  }

  get source(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get measure(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get dripRatePerSecond(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SetBalanceDripRateCall__Outputs {
  _call: SetBalanceDripRateCall;

  constructor(call: SetBalanceDripRateCall) {
    this._call = call;
  }
}

export class SetVolumeDripCall extends ethereum.Call {
  get inputs(): SetVolumeDripCall__Inputs {
    return new SetVolumeDripCall__Inputs(this);
  }

  get outputs(): SetVolumeDripCall__Outputs {
    return new SetVolumeDripCall__Outputs(this);
  }
}

export class SetVolumeDripCall__Inputs {
  _call: SetVolumeDripCall;

  constructor(call: SetVolumeDripCall) {
    this._call = call;
  }

  get source(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get measure(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get isReferral(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get periodSeconds(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get dripAmount(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }
}

export class SetVolumeDripCall__Outputs {
  _call: SetVolumeDripCall;

  constructor(call: SetVolumeDripCall) {
    this._call = call;
  }
}

export class TransferOutCall extends ethereum.Call {
  get inputs(): TransferOutCall__Inputs {
    return new TransferOutCall__Inputs(this);
  }

  get outputs(): TransferOutCall__Outputs {
    return new TransferOutCall__Outputs(this);
  }
}

export class TransferOutCall__Inputs {
  _call: TransferOutCall;

  constructor(call: TransferOutCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferOutCall__Outputs {
  _call: TransferOutCall;

  constructor(call: TransferOutCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UpdateActiveBalanceDripsForPairsCall extends ethereum.Call {
  get inputs(): UpdateActiveBalanceDripsForPairsCall__Inputs {
    return new UpdateActiveBalanceDripsForPairsCall__Inputs(this);
  }

  get outputs(): UpdateActiveBalanceDripsForPairsCall__Outputs {
    return new UpdateActiveBalanceDripsForPairsCall__Outputs(this);
  }
}

export class UpdateActiveBalanceDripsForPairsCall__Inputs {
  _call: UpdateActiveBalanceDripsForPairsCall;

  constructor(call: UpdateActiveBalanceDripsForPairsCall) {
    this._call = call;
  }

  get pairs(): Array<UpdateActiveBalanceDripsForPairsCallPairsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      UpdateActiveBalanceDripsForPairsCallPairsStruct
    >();
  }
}

export class UpdateActiveBalanceDripsForPairsCall__Outputs {
  _call: UpdateActiveBalanceDripsForPairsCall;

  constructor(call: UpdateActiveBalanceDripsForPairsCall) {
    this._call = call;
  }
}

export class UpdateActiveBalanceDripsForPairsCallPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class UpdateActiveVolumeDripsForPairsCall extends ethereum.Call {
  get inputs(): UpdateActiveVolumeDripsForPairsCall__Inputs {
    return new UpdateActiveVolumeDripsForPairsCall__Inputs(this);
  }

  get outputs(): UpdateActiveVolumeDripsForPairsCall__Outputs {
    return new UpdateActiveVolumeDripsForPairsCall__Outputs(this);
  }
}

export class UpdateActiveVolumeDripsForPairsCall__Inputs {
  _call: UpdateActiveVolumeDripsForPairsCall;

  constructor(call: UpdateActiveVolumeDripsForPairsCall) {
    this._call = call;
  }

  get pairs(): Array<UpdateActiveVolumeDripsForPairsCallPairsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      UpdateActiveVolumeDripsForPairsCallPairsStruct
    >();
  }
}

export class UpdateActiveVolumeDripsForPairsCall__Outputs {
  _call: UpdateActiveVolumeDripsForPairsCall;

  constructor(call: UpdateActiveVolumeDripsForPairsCall) {
    this._call = call;
  }
}

export class UpdateActiveVolumeDripsForPairsCallPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class UpdateAndClaimDripsCall extends ethereum.Call {
  get inputs(): UpdateAndClaimDripsCall__Inputs {
    return new UpdateAndClaimDripsCall__Inputs(this);
  }

  get outputs(): UpdateAndClaimDripsCall__Outputs {
    return new UpdateAndClaimDripsCall__Outputs(this);
  }
}

export class UpdateAndClaimDripsCall__Inputs {
  _call: UpdateAndClaimDripsCall;

  constructor(call: UpdateAndClaimDripsCall) {
    this._call = call;
  }

  get pairs(): Array<UpdateAndClaimDripsCallPairsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      UpdateAndClaimDripsCallPairsStruct
    >();
  }

  get user(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripTokens(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }
}

export class UpdateAndClaimDripsCall__Outputs {
  _call: UpdateAndClaimDripsCall;

  constructor(call: UpdateAndClaimDripsCall) {
    this._call = call;
  }

  get value0(): Array<UpdateAndClaimDripsCallValue0Struct> {
    return this._call.outputValues[0].value.toTupleArray<
      UpdateAndClaimDripsCallValue0Struct
    >();
  }
}

export class UpdateAndClaimDripsCallPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class UpdateAndClaimDripsCallValue0Struct extends ethereum.Tuple {
  get dripToken(): Address {
    return this[0].toAddress();
  }

  get balance(): BigInt {
    return this[1].toBigInt();
  }
}

export class UpdateDripsCall extends ethereum.Call {
  get inputs(): UpdateDripsCall__Inputs {
    return new UpdateDripsCall__Inputs(this);
  }

  get outputs(): UpdateDripsCall__Outputs {
    return new UpdateDripsCall__Outputs(this);
  }
}

export class UpdateDripsCall__Inputs {
  _call: UpdateDripsCall;

  constructor(call: UpdateDripsCall) {
    this._call = call;
  }

  get pairs(): Array<UpdateDripsCallPairsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      UpdateDripsCallPairsStruct
    >();
  }

  get user(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get dripTokens(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }
}

export class UpdateDripsCall__Outputs {
  _call: UpdateDripsCall;

  constructor(call: UpdateDripsCall) {
    this._call = call;
  }

  get value0(): Array<UpdateDripsCallValue0Struct> {
    return this._call.outputValues[0].value.toTupleArray<
      UpdateDripsCallValue0Struct
    >();
  }
}

export class UpdateDripsCallPairsStruct extends ethereum.Tuple {
  get source(): Address {
    return this[0].toAddress();
  }

  get measure(): Address {
    return this[1].toAddress();
  }
}

export class UpdateDripsCallValue0Struct extends ethereum.Tuple {
  get dripToken(): Address {
    return this[0].toAddress();
  }

  get balance(): BigInt {
    return this[1].toBigInt();
  }
}
